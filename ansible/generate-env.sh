#!/usr/bin/env bash
# generate-env.sh — Generate environment-specific .env files with cryptographically random secrets
# Usage: ./generate-env.sh <environment> [--force]
#        ./generate-env.sh local [--force]
#        ./generate-env.sh staging [--force]
#        ./generate-env.sh production [--force]
#
# Generates all required secrets and writes ansible/.env.<environment>
# Will NOT overwrite an existing .env file unless --force is passed.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ─── Parse arguments ─────────────────────────────────────────────────────────

ENVIRONMENT="${1:-}"
FORCE_FLAG="${2:-}"

if [[ -z "$ENVIRONMENT" ]]; then
  echo "ERROR: Environment argument is required."
  echo ""
  echo "Usage: $0 <environment> [--force]"
  echo ""
  echo "Available environments:"
  echo "  local       - Local development environment"
  echo "  staging     - Staging server environment"
  echo "  production  - Production cluster environment"
  echo ""
  echo "Example: $0 production"
  exit 1
fi

if [[ ! "$ENVIRONMENT" =~ ^(local|staging|production)$ ]]; then
  echo "ERROR: Invalid environment: $ENVIRONMENT"
  echo "Valid environments are: local, staging, production"
  exit 1
fi

ENV_FILE="${SCRIPT_DIR}/.env.${ENVIRONMENT}"

# ─── Pre-flight checks ───────────────────────────────────────────────────────

if [[ -f "$ENV_FILE" ]] && [[ "$FORCE_FLAG" != "--force" ]]; then
  echo "ERROR: ${ENV_FILE} already exists."
  echo "  Use --force to overwrite, or edit the existing file."
  exit 1
fi

command -v openssl >/dev/null 2>&1 || { echo "ERROR: openssl is required"; exit 1; }

# ─── Load external configs ──────────────────────────────────────────────────

echo "Generating .env file for environment: ${ENVIRONMENT}"
echo ""

# Always load SMTP config (shared across all environments)
SMTP_ENV="${SCRIPT_DIR}/.smtp.env"
if [[ -f "$SMTP_ENV" ]]; then
  # shellcheck source=/dev/null
  source "$SMTP_ENV"
  echo "✓ Loaded SMTP config from .smtp.env"
else
  echo "⚠ No .smtp.env found — SMTP will be empty"
fi

# Load environment-specific config
case "$ENVIRONMENT" in
  production)
    PROD_ENV="${SCRIPT_DIR}/.prod.env"
    if [[ -f "$PROD_ENV" ]]; then
      # shellcheck source=/dev/null
      source "$PROD_ENV"
      echo "✓ Loaded production config from .prod.env"
    else
      echo "⚠ No .prod.env found — production values will be empty"
    fi

    BACKUP_ENV="${SCRIPT_DIR}/.backup.env"
    if [[ -f "$BACKUP_ENV" ]]; then
      # shellcheck source=/dev/null
      source "$BACKUP_ENV"
      echo "✓ Loaded backup config from .backup.env"
    fi
    ;;

  staging)
    STAGING_ENV="${SCRIPT_DIR}/.staging.env"
    if [[ -f "$STAGING_ENV" ]]; then
      # shellcheck source=/dev/null
      source "$STAGING_ENV"
      echo "✓ Loaded staging config from .staging.env"
    else
      echo "⚠ No .staging.env found — staging values will be empty"
    fi
    ;;

  local)
    # Local doesn't need external config, uses defaults
    echo "✓ Using local defaults"
    ;;
esac

echo ""

# ─── Secret generators ───────────────────────────────────────────────────────

hex32()   { openssl rand -hex 32; }
b64_24()  { openssl rand -base64 24 | tr -d '\n'; }
b64_32()  { openssl rand -base64 32 | tr -d '\n'; }
b64_16()  { openssl rand -base64 16 | tr -d '\n'; }
alphanum() { openssl rand -base64 "${1:-24}" | tr -dc 'A-Za-z0-9' | head -c "${1:-24}"; }

# ─── Generate secrets ─────────────────────────────────────────────────────────

K3S_TOKEN="$(hex32)"
POSTGRES_SUPERUSER_PASSWORD="$(b64_24)"
POSTGRES_REPLICATION_PASSWORD="$(b64_24)"
REDIS_PASSWORD="$(b64_24)"
LONGHORN_CRYPTO_KEY="$(b64_32)"
ETCD_ENCRYPTION_KEY="$(b64_32)"

# Service admin passwords
KEYCLOAK_ADMIN_PASSWORD="$(alphanum 24)"
MATTERMOST_ADMIN_PASSWORD="$(alphanum 24)"
NEXTCLOUD_ADMIN_PASSWORD="$(alphanum 24)"
GITEA_ADMIN_PASSWORD="$(alphanum 24)"
ARGOCD_ADMIN_PASSWORD="$(alphanum 24)"
GRAFANA_ADMIN_PASSWORD="$(alphanum 24)"

# Per-service DB passwords
VAULT_DB_PASSWORD="$(b64_24)"
KEYCLOAK_DB_PASSWORD="$(b64_24)"
MATTERMOST_DB_PASSWORD="$(b64_24)"
NEXTCLOUD_DB_PASSWORD="$(b64_24)"
GITEA_DB_PASSWORD="$(b64_24)"
REDCAP_DB_PASSWORD="$(b64_24)"
FLIPT_DB_PASSWORD="$(b64_24)"

# Service secrets
REDCAP_SALT="$(b64_32)"
SEAWEEDFS_S3_ACCESS_KEY="$(alphanum 20)"
SEAWEEDFS_S3_SECRET_KEY="$(b64_32)"
ONLYOFFICE_JWT_SECRET="$(b64_32)"

# Backup encryption key (only if backup is enabled)
if [[ "${BACKUP_ENABLED:-false}" == "true" ]]; then
  BACKUP_ENCRYPTION_KEY="$(b64_32)"
fi

# ─── Write .env ───────────────────────────────────────────────────────────────

cat > "$ENV_FILE" <<ENVFILE
# ATLAS Platform - Environment: ${ENVIRONMENT}
# Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
# Generated by: generate-env.sh ${ENVIRONMENT}
#
# IMPORTANT: This file is for ${ENVIRONMENT} environment only.
# To generate for a different environment, run: ./generate-env.sh <environment>

# =============================================================================
# REQUIRED - All Environments
# =============================================================================

export K3S_TOKEN="${K3S_TOKEN}"
export POSTGRES_SUPERUSER_PASSWORD="${POSTGRES_SUPERUSER_PASSWORD}"
export POSTGRES_REPLICATION_PASSWORD="${POSTGRES_REPLICATION_PASSWORD}"
export REDIS_PASSWORD="${REDIS_PASSWORD}"
ENVFILE

# Environment-specific sections
case "$ENVIRONMENT" in
  production)
    cat >> "$ENV_FILE" <<ENVFILE

# =============================================================================
# PRODUCTION CONFIGURATION
# =============================================================================
# Loaded from: .prod.env

export PROD_DOMAIN="${PROD_DOMAIN:-}"
export ADMIN_IP="${ADMIN_IP:-}"
export LETSENCRYPT_EMAIL="${LETSENCRYPT_EMAIL:-}"

# Production server IPs
export PROD_MASTER_HOST="${PROD_MASTER_HOST:-}"
export PROD_WORKER1_HOST="${PROD_WORKER1_HOST:-}"
export PROD_WORKER2_HOST="${PROD_WORKER2_HOST:-}"
export PROD_WORKER3_HOST="${PROD_WORKER3_HOST:-}"
export PROD_SSH_KEY="${PROD_SSH_KEY:-~/.ssh/production_key}"
ENVFILE
    ;;

  staging)
    cat >> "$ENV_FILE" <<ENVFILE

# =============================================================================
# STAGING CONFIGURATION
# =============================================================================
# Loaded from: .staging.env

export STAGING_DOMAIN="${STAGING_DOMAIN:-}"
export STAGING_HOST="${STAGING_HOST:-}"
export STAGING_SSH_KEY="${STAGING_SSH_KEY:-~/.ssh/staging_key}"
ENVFILE
    ;;

  local)
    cat >> "$ENV_FILE" <<ENVFILE

# =============================================================================
# LOCAL CONFIGURATION
# =============================================================================

# Local development uses localhost defaults
# No additional configuration needed
ENVFILE
    ;;
esac

# Continue with shared sections
cat >> "$ENV_FILE" <<ENVFILE

# =============================================================================
# ENCRYPTION KEYS
# =============================================================================

export LONGHORN_CRYPTO_KEY="${LONGHORN_CRYPTO_KEY}"
export ETCD_ENCRYPTION_KEY="${ETCD_ENCRYPTION_KEY}"

# =============================================================================
# VAULT (leave empty until after vault init, then paste the output)
# =============================================================================

export VAULT_ROOT_TOKEN=""
export VAULT_UNSEAL_KEYS='[]'

# =============================================================================
# SERVICE ADMIN PASSWORDS
# =============================================================================

export KEYCLOAK_ADMIN_PASSWORD="${KEYCLOAK_ADMIN_PASSWORD}"
export MATTERMOST_ADMIN_PASSWORD="${MATTERMOST_ADMIN_PASSWORD}"
export NEXTCLOUD_ADMIN_PASSWORD="${NEXTCLOUD_ADMIN_PASSWORD}"
export GITEA_ADMIN_PASSWORD="${GITEA_ADMIN_PASSWORD}"
export ARGOCD_ADMIN_PASSWORD="${ARGOCD_ADMIN_PASSWORD}"
export GRAFANA_ADMIN_PASSWORD="${GRAFANA_ADMIN_PASSWORD}"

# =============================================================================
# PER-SERVICE DATABASE PASSWORDS
# =============================================================================

export VAULT_DB_PASSWORD="${VAULT_DB_PASSWORD}"
export KEYCLOAK_DB_PASSWORD="${KEYCLOAK_DB_PASSWORD}"
export MATTERMOST_DB_PASSWORD="${MATTERMOST_DB_PASSWORD}"
export NEXTCLOUD_DB_PASSWORD="${NEXTCLOUD_DB_PASSWORD}"
export GITEA_DB_PASSWORD="${GITEA_DB_PASSWORD}"
export REDCAP_DB_PASSWORD="${REDCAP_DB_PASSWORD}"
export FLIPT_DB_PASSWORD="${FLIPT_DB_PASSWORD}"

# =============================================================================
# SERVICE SECRETS
# =============================================================================

export REDCAP_SALT="${REDCAP_SALT}"
export SEAWEEDFS_S3_ACCESS_KEY="${SEAWEEDFS_S3_ACCESS_KEY}"
export SEAWEEDFS_S3_SECRET_KEY="${SEAWEEDFS_S3_SECRET_KEY}"
export ONLYOFFICE_JWT_SECRET="${ONLYOFFICE_JWT_SECRET}"

# =============================================================================
# SMTP (Email delivery via Brevo or other provider)
# =============================================================================
# To configure: edit .smtp.env then re-run generate-env.sh

export SMTP_HOST="${SMTP_HOST:-}"
export SMTP_PORT="${SMTP_PORT:-587}"
export SMTP_USER="${SMTP_USER:-}"
export SMTP_PASSWORD="${SMTP_PASSWORD:-}"
export SMTP_FROM="${SMTP_FROM:-}"

ENVFILE

# Production-only optional features
if [[ "$ENVIRONMENT" == "production" ]]; then
  cat >> "$ENV_FILE" <<ENVFILE

# =============================================================================
# OPTIONAL - Vault Auto-Unseal (Production only)
# =============================================================================

export VAULT_AUTO_UNSEAL_ENABLED="${VAULT_AUTO_UNSEAL_ENABLED:-false}"
export VAULT_AUTO_UNSEAL_TYPE="${VAULT_AUTO_UNSEAL_TYPE:-}"
export AWS_REGION="${AWS_REGION:-}"
export VAULT_AWSKMS_KEY_ID="${VAULT_AWSKMS_KEY_ID:-}"

# =============================================================================
# OPTIONAL - Off-Site Backup (Production only)
# =============================================================================
# Loaded from: .backup.env

export BACKUP_ENABLED="${BACKUP_ENABLED:-false}"
export BACKUP_S3_ENDPOINT="${BACKUP_S3_ENDPOINT:-}"
export BACKUP_S3_BUCKET="${BACKUP_S3_BUCKET:-}"
export BACKUP_S3_REGION="${BACKUP_S3_REGION:-}"
export BACKUP_S3_ACCESS_KEY="${BACKUP_S3_ACCESS_KEY:-}"
export BACKUP_S3_SECRET_KEY="${BACKUP_S3_SECRET_KEY:-}"
export BACKUP_ENCRYPTION_KEY="${BACKUP_ENCRYPTION_KEY:-}"
ENVFILE
fi

# Close the heredoc properly
cat >> "$ENV_FILE" <<'ENVFILE'
ENVFILE

# ─── Permissions ──────────────────────────────────────────────────────────────

chmod 600 "$ENV_FILE"

# ─── Summary ─────────────────────────────────────────────────────────────────

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "✓ Generated: ${ENV_FILE}"
echo "  Permissions: 600 (owner read/write only)"
echo "  Environment: ${ENVIRONMENT}"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""
echo "Secrets generated:"
echo "  • 1  K3s cluster token (hex, 256-bit)"
echo "  • 3  Database passwords (PostgreSQL superuser, replication, Redis)"
echo "  • 7  Per-service DB passwords (Vault, Keycloak, Mattermost, Nextcloud, Gitea, REDCap, Flipt)"
echo "  • 6  Admin passwords (Keycloak, Mattermost, Nextcloud, Gitea, ArgoCD, Grafana)"
echo "  • 2  Encryption keys (Longhorn LUKS, etcd at-rest)"
echo "  • 3  Service secrets (REDCap salt, SeaweedFS S3, OnlyOffice JWT)"
if [[ "$ENVIRONMENT" == "production" ]] && [[ "${BACKUP_ENABLED:-false}" == "true" ]]; then
  echo "  • 1  Backup encryption key"
fi
echo ""
echo "Next steps:"
echo "  1. Source the environment file:"
echo "     source ${ENV_FILE}"
echo ""
echo "  2. Deploy to ${ENVIRONMENT}:"
echo "     ansible-playbook -i inventories/${ENVIRONMENT}/ playbooks/phase-00-bootstrap.yml"
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "⚠️  IMPORTANT: Back up this file securely. These secrets cannot be recovered."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
